/**
 * Report Generator for Scientific Benchmarks
 *
 * Generates comprehensive markdown reports from benchmark results.
 * Includes statistical analysis, comparisons, and visualizations.
 */

import type {
  BenchmarkResult,
  ComparisonResult,
  BenchmarkSummary,
  ScenarioResult,
} from "./types.js";
import { SCENARIO_DESCRIPTIONS } from "./types.js";

/**
 * Generate a complete markdown report from benchmark results
 *
 * @param result - The benchmark result to report on
 * @returns Markdown string
 */
export function generateMarkdownReport(result: BenchmarkResult): string {
  const sections: string[] = [];

  // Title
  sections.push("# Vesper Benchmark Report\n");

  // Timestamp
  const timestamp = new Date(result.endTime).toISOString();
  sections.push(`**Generated:** ${timestamp}\n`);
  sections.push(`**Benchmark ID:** ${result.id}\n`);
  sections.push(`**Duration:** ${formatDuration(result.endTime - result.startTime)}\n`);
  sections.push("");

  // Summary
  sections.push("## Summary\n");
  sections.push(generateSummaryTable(result.summary));
  sections.push("");

  // Overall conclusion
  sections.push(generateConclusion(result.summary));
  sections.push("");

  // Detailed comparisons
  sections.push("## Scenario Results\n");
  for (const comparison of result.comparisons) {
    sections.push(generateComparisonSection(comparison));
    sections.push("");
  }

  // Configuration
  sections.push("## Configuration\n");
  sections.push(generateConfigSection(result));
  sections.push("");

  // Metadata
  sections.push("## Metadata\n");
  sections.push(generateMetadataSection(result));
  sections.push("");

  // Footer
  sections.push("---\n");
  sections.push(
    "*Report generated by Vesper Scientific Benchmark System*\n"
  );
  sections.push(
    "*Run benchmarks yourself: `npm run benchmark:scientific`*\n"
  );

  return sections.join("\n");
}

/**
 * Generate summary table
 */
export function generateSummaryTable(summary: BenchmarkSummary): string {
  const rows = [
    ["Metric", "Value"],
    ["---", "---"],
    ["Total Scenarios", String(summary.totalScenarios)],
    ["Vesper Wins", String(summary.vesperWins)],
    ["Disabled Wins", String(summary.disabledWins)],
    ["Ties", String(summary.ties)],
    ["Overall Improvement", formatPercentage(summary.overallImprovement)],
    ["Statistically Significant", summary.statisticallySignificant ? "Yes" : "No"],
  ];

  return rows.map((row) => `| ${row.join(" | ")} |`).join("\n");
}

/**
 * Generate conclusion based on summary
 */
function generateConclusion(summary: BenchmarkSummary): string {
  const winRate = (summary.vesperWins / summary.totalScenarios) * 100;

  let conclusion = "### Conclusion\n\n";

  if (winRate >= 80 && summary.statisticallySignificant) {
    conclusion += `Vesper demonstrates **strong, statistically significant improvements** across ${summary.vesperWins}/${summary.totalScenarios} scenarios. `;
    conclusion += `Average improvement of ${formatPercentage(summary.overallImprovement)}.\n`;
  } else if (winRate >= 60) {
    conclusion += `Vesper shows **moderate improvements** in ${summary.vesperWins}/${summary.totalScenarios} scenarios. `;
    conclusion += `Further testing recommended to confirm statistical significance.\n`;
  } else if (winRate >= 40) {
    conclusion += `Results are **mixed**, with Vesper winning ${summary.vesperWins}/${summary.totalScenarios} scenarios. `;
    conclusion += `Consider scenario-specific optimizations.\n`;
  } else {
    conclusion += `Vesper shows **limited improvement** in current configuration. `;
    conclusion += `Review implementation and test methodology.\n`;
  }

  return conclusion;
}

/**
 * Generate comparison section for a scenario
 */
export function generateComparisonSection(comparison: ComparisonResult): string {
  const sections: string[] = [];

  // Scenario header
  const scenarioName = comparison.scenarioType.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
  sections.push(`### ${scenarioName}\n`);

  // Description
  const description = SCENARIO_DESCRIPTIONS[comparison.scenarioType] || "";
  if (description) {
    sections.push(`*${description}*\n`);
  }

  // Winner badge
  const winnerText = comparison.winner === "vesper-enabled"
    ? "**Winner: Vesper Enabled**"
    : comparison.winner === "vesper-disabled"
    ? "**Winner: Vesper Disabled**"
    : "**Result: Tie**";
  sections.push(winnerText + "\n");

  // Latency comparison table
  sections.push("#### Latency (ms)\n");
  sections.push(
    "| Metric | Vesper Enabled | Vesper Disabled | Improvement |"
  );
  sections.push("| --- | --- | --- | --- |");
  sections.push(
    `| P50 | ${formatNumber(comparison.enabledResult.aggregates.latencyP50, 1)} | ${formatNumber(comparison.disabledResult.aggregates.latencyP50, 1)} | ${calculateImprovementText(comparison.enabledResult.aggregates.latencyP50, comparison.disabledResult.aggregates.latencyP50)} |`
  );
  sections.push(
    `| P95 | ${formatNumber(comparison.enabledResult.aggregates.latencyP95, 1)} | ${formatNumber(comparison.disabledResult.aggregates.latencyP95, 1)} | ${calculateImprovementText(comparison.enabledResult.aggregates.latencyP95, comparison.disabledResult.aggregates.latencyP95)} |`
  );
  sections.push(
    `| P99 | ${formatNumber(comparison.enabledResult.aggregates.latencyP99, 1)} | ${formatNumber(comparison.disabledResult.aggregates.latencyP99, 1)} | ${calculateImprovementText(comparison.enabledResult.aggregates.latencyP99, comparison.disabledResult.aggregates.latencyP99)} |`
  );
  sections.push("");

  // Memory hit rate
  if (
    comparison.enabledResult.aggregates.memoryHitRate !== undefined ||
    comparison.disabledResult.aggregates.memoryHitRate !== undefined
  ) {
    const enabledHitRate = comparison.enabledResult.aggregates.memoryHitRate ?? 0;
    const disabledHitRate = comparison.disabledResult.aggregates.memoryHitRate ?? 0;
    sections.push(`**Memory Hit Rate:** Enabled: ${formatPercentage(enabledHitRate * 100)}, Disabled: ${formatPercentage(disabledHitRate * 100)}\n`);
  }

  // Statistical analysis
  sections.push("#### Statistical Analysis\n");
  const stats = comparison.statistics;
  sections.push(`- **Latency Improvement:** ${formatPercentage(stats.latencyImprovement)}`);
  sections.push(`- **t-test statistic:** ${formatNumber(stats.tTestResult.tStatistic, 3)}`);
  sections.push(`- **p-value:** ${formatNumber(stats.tTestResult.pValue, 4)}`);
  sections.push(`- **Significant (p < ${stats.tTestResult.alpha}):** ${stats.tTestResult.significant ? "Yes" : "No"}`);
  sections.push(`- **Cohen's d:** ${formatNumber(stats.effectSize.cohensD, 3)} (${stats.effectSize.interpretation})`);
  sections.push("");

  return sections.join("\n");
}

/**
 * Calculate improvement text for a metric
 */
function calculateImprovementText(enabled: number, disabled: number): string {
  if (disabled === 0) return "N/A";
  const improvement = ((disabled - enabled) / disabled) * 100;
  return formatPercentage(improvement);
}

/**
 * Generate configuration section
 */
function generateConfigSection(result: BenchmarkResult): string {
  const config = result.config;
  const rows = [
    ["Setting", "Value"],
    ["---", "---"],
    ["Warmup Runs", String(config.warmupRuns)],
    ["Measurement Runs", String(config.measurementRuns)],
    ["Timeout (ms)", String(config.timeoutMs)],
    ["Significance Level (alpha)", String(config.significanceLevel)],
    ["Scenarios", config.scenarios.join(", ")],
    ["Output Directory", config.outputDirectory],
  ];

  return rows.map((row) => `| ${row.join(" | ")} |`).join("\n");
}

/**
 * Generate metadata section
 */
function generateMetadataSection(result: BenchmarkResult): string {
  const meta = result.metadata;
  const rows = [
    ["Property", "Value"],
    ["---", "---"],
    ["Version", meta.version],
    ["Environment", meta.environment],
  ];

  if (meta.hostname) {
    rows.push(["Hostname", meta.hostname]);
  }
  if (meta.nodeVersion) {
    rows.push(["Node Version", meta.nodeVersion]);
  }

  return rows.map((row) => `| ${row.join(" | ")} |`).join("\n");
}

// =============================================================================
// Formatting Helper Functions
// =============================================================================

/**
 * Format a number with optional decimal places and thousand separators
 */
export function formatNumber(value: number, decimals: number = 0): string {
  if (decimals === 0) {
    return value.toLocaleString("en-US", { maximumFractionDigits: 0 });
  }
  return value.toFixed(decimals);
}

/**
 * Format a percentage with sign
 */
export function formatPercentage(value: number): string {
  const formatted = value.toFixed(1);
  if (value > 0) {
    return `+${formatted}%`;
  }
  if (value < 0) {
    return `${formatted}%`;
  }
  return `${formatted}%`;
}

/**
 * Format duration in human-readable format
 */
export function formatDuration(ms: number): string {
  if (ms < 1000) {
    return `${ms}ms`;
  }
  if (ms < 60000) {
    return `${(ms / 1000).toFixed(1)}s`;
  }
  const minutes = Math.floor(ms / 60000);
  const seconds = Math.floor((ms % 60000) / 1000);
  return `${minutes}m ${seconds}s`;
}
